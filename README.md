This repo contains various design patterns in java. We will be covering following design patterns in this repo

1. Factory Design pattern
2. Builder Design pattern
3. Adaptor Design pattern
4. Composite Design pattern
5. Prototype Design pattern
6. Observer Design pattern

Design patterns are general reusable solutions to common problems that occur during software development. In Java, as in many other object-oriented programming languages, there are several design patterns commonly used to address various design challenges. Here are some of the most commonly used design patterns in Java:

1. **Singleton Pattern**:
   - Ensures that a class has only one instance and provides a global point of access to that instance.

2. **Factory Method Pattern**:
   - Defines an interface for creating an object, but lets subclasses alter the type of objects that will be created.

3. **Abstract Factory Pattern**:
   - Provides an interface for creating families of related or dependent objects without specifying their concrete classes.

4. **Builder Pattern**:
   - Separates the construction of a complex object from its representation, allowing the same construction process to create various representations.

5. **Prototype Pattern**:
   - Creates new objects by copying an existing object, known as a prototype, during runtime.

6. **Adapter Pattern**:
   - Allows objects with incompatible interfaces to collaborate by converting the interface of one object so that it matches the interface of another.

7. **Decorator Pattern**:
   - Adds behavior to objects dynamically without affecting the behavior of other objects from the same class.

8. **Proxy Pattern**:
   - Provides a placeholder or surrogate for another object to control access to it.

9. **Observer Pattern**:
   - Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

10. **Strategy Pattern**:
    - Defines a family of algorithms, encapsulates each one, and makes them interchangeable, allowing the client to choose the algorithm at runtime.

11. **Command Pattern**:
    - Encapsulates a request as an object, thereby allowing parameterization of clients with queues, requests, and operations.

12. **State Pattern**:
    - Allows an object to alter its behavior when its internal state changes, the object will appear to change its class.

13. **Composite Pattern**:
    - Composes objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.

14. **Iterator Pattern**:
    - Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

15. **Template Method Pattern**:
    - Defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.

These design patterns help in creating software that is more maintainable, scalable, and flexible by promoting code reusability and separation of concerns. Understanding and applying these patterns appropriately can significantly improve the quality of Java applications.
